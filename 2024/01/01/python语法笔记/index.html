<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>python语法笔记 | Harlon Yan</title><meta name="author" content="Harlon Yan"><meta name="copyright" content="Harlon Yan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇文章是一份关于Python语法的笔记，涵盖了变量引用、数据类型、函数、循环、数据结构（如列表、元组、字典等）、文件操作、异常处理、类与对象等核心语法">
<meta property="og:type" content="article">
<meta property="og:title" content="python语法笔记">
<meta property="og:url" content="http://example.com/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Harlon Yan">
<meta property="og:description" content="这篇文章是一份关于Python语法的笔记，涵盖了变量引用、数据类型、函数、循环、数据结构（如列表、元组、字典等）、文件操作、异常处理、类与对象等核心语法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg">
<meta property="article:published_time" content="2023-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-29T03:51:15.888Z">
<meta property="article:author" content="Harlon Yan">
<meta property="article:tag" content="Causal inference">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "python语法笔记",
  "url": "http://example.com/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/",
  "image": "https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg",
  "datePublished": "2023-12-31T16:00:00.000Z",
  "dateModified": "2025-01-29T03:51:15.888Z",
  "author": [
    {
      "@type": "Person",
      "name": "Harlon Yan",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python语法笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/Cf5h3dytAMaYg21.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Harlon Yan</span></a><a class="nav-page-title" href="/"><span class="site-name">python语法笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">python语法笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-29T03:51:15.888Z" title="更新于 2025-01-29 11:51:15">2025-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learning-Notes/">Learning Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1
id="python中的变量与对象之间的引用">Python中的<u>变量</u>与<u>对象</u>之间的<u>引用</u></h1>
<p>C语言中的"变量"与Python中的"变量"不同。</p>
<h2 id="c语言">C语言</h2>
<p>在C语言中，变量与对象之间的关系是"箱子"与"物体"。</p>
<p><strong>初始化（声明并赋值）一个变量</strong>时会声明一块存储空间并写入一个值，相当于创造一个"箱子"并放入一个"物体"；</p>
<p><strong>改变这一变量的值</strong>会直接修改这一存储空间的内容，相当于用另外一个"物体"替换"箱子"里原有的"物体"；</p>
<p><strong>把一个变量赋值给另一个变量时</strong>，相当于把"箱子"里的"物体"复制一份儿然后放到另一个"箱子"里面，之后两个"箱子"各自独立，互不影响。</p>
<p>代码如下</p>
<p>1. int a = 100 //在地址1处创建一个箱子a并放入物体100</p>
<p>2. a = 200 // 箱子a里的物体100被替换成物体200</p>
<p>3. int b = a //
在另一个地址2处创建一个箱子b，之后把箱子a中的物体复制一份放入箱子b中。箱子a与b是相互独立、互不影响的两个箱子。</p>
<h2 id="python">Python</h2>
<p>在Python中，一切皆为对象。变量是对内存中对象的一个引用，两者的关系相对独立，各有各自的存储空间。在Python中，变量与对象之间的关系是"标签"与"商品"。</p>
<p><img src="https://s2.loli.net/2025/01/28/e8iYfSZNTPdn1lv.png"
style="width:3.32285in;height:2.37905in" /></p>
<p><strong>变量位于栈内存，对象位于堆内存。</strong>对象中包含地址、类型、值，因此Python中的变量不需要声明数据类型，在引用的过程中能通过所引用的对象自动识别数据类型。</p>
<p><strong>初始化（声明并赋值）一个变量</strong>时，首先在一块儿存储空间写入一个对象，这一步相当于创建了一个"商品"，之后声明另外一块存储空间为变量，这一步相当于创造了一个"标签"。最后，将对象的地址写入变量，这一过程叫做引用，相当于把"标签"挂在"商品"上面，后续通过"标签"找到"商品"。</p>
<p><strong>把一个变量赋值给另外一个变量时，</strong>并不会赋值对象，而只是简单添加一条引用，相当于在原来的"商品"上新挂了一个"标签"，两个"标签"共享一个"商品"。</p>
<p>a = 100
#开辟一片存储空间写入对象100，开辟一片存储空间声明一个变量a，将100的地址写入变量a中<br />
a = 200 #开辟另一片存储空间写入对象200，将200的地址写入变量a中<br />
b = a
#开辟一片存储空间声明一个变量b，将a的引用（即200的地址）赋给b，即将200的地址写入变量b中<br />
#100由于没有变量承载，会被自动销毁<br />
print(b)<br />
print(id(100)) #返回对象的唯一标识符/内存地址<br />
print(id(200))<br />
print(id(a)) #返回变量所引用的对象的唯一标识符/内存地址<br />
print(id(b))<br />
print(id(id(a))) #
id(a)返回一个整数值，id(id(a))相当于创建一个值等于id(a)对象，再返回其内存地址。相当于下面的print(id(c))<br />
print(id(id(b)))<br />
c = id(a)</p>
<p>d = id(b)<br />
print(id(c))</p>
<p>print(id(d))</p>
<p>200</p>
<p>140717808965144</p>
<p>140717808968344</p>
<p>140717808968344</p>
<p>140717808968344</p>
<p>1631067745744</p>
<p>1631067740464</p>
<p>1631067745744</p>
<p>1631067740464</p>
<p>print(a is b) #is 比较两个变量所引用对象的地址</p>
<p>print(a == b) #== 比较两个变量所引用对象的值</p>
<p>print(id(a) is id(b)) #相当于比较id(id(a))== id(id(b))，也就是id(c)==
id(d)</p>
<p>print(id(a) == id(b)) #比较两个变量所引用对象的地址的值大小</p>
<p>True</p>
<p>True</p>
<p>False</p>
<p>True</p>
<h3 id="可变对象和不可变对象的赋值">可变对象和不可变对象的赋值</h3>
<p>Python里常见的可变对象有列表 list、字典 dict、集合
set，不可变对象有数值类型 (int、float 等)、字符串 str、元组 tuple。</p>
<p>结论一：两个变量的引用对象即使数值相同，内存地址也大多不同（<strong>"大多"是因为要考虑python的对象复用机制，见后文。</strong>）</p>
<p>#直接在cmd中和python解释器进行交互，而非pycharm等</p>
<p>#python整数复用范围在[-5,256],超过这一范围将分配不同的地址</p>
<p>&gt;&gt;&gt; a = -5</p>
<p>&gt;&gt;&gt; b = -5</p>
<p>&gt;&gt;&gt; id(a)==id(b)</p>
<p>True</p>
<p>&gt;&gt;&gt; a = -6</p>
<p>&gt;&gt;&gt; b = -6</p>
<p>&gt;&gt;&gt; id(a) == id(b)</p>
<p>False</p>
<p>&gt;&gt;&gt; a = 256</p>
<p>&gt;&gt;&gt; b = 256</p>
<p>&gt;&gt;&gt; id(a) == id(b)</p>
<p>True</p>
<p>&gt;&gt;&gt; a = 257</p>
<p>&gt;&gt;&gt; b = 257</p>
<p>&gt;&gt;&gt; id(a) == id(b)</p>
<p>False</p>
<p>#python字符复用范围在不带空格的、不过长的字符串，不符合这两个要求将分配不同的地址</p>
<p>&gt;&gt;&gt; a = "hello"</p>
<p>&gt;&gt;&gt; b = "hello"</p>
<p>&gt;&gt;&gt; id(a)</p>
<p>2101981600272</p>
<p>&gt;&gt;&gt; id(b)</p>
<p>2101981600272</p>
<p>&gt;&gt;&gt; a = "he llo"</p>
<p>&gt;&gt;&gt; b = "he llo"</p>
<p>&gt;&gt;&gt; id(a)</p>
<p>2101981598400</p>
<p>&gt;&gt;&gt; id(b)</p>
<p>2101981600080</p>
<p>&gt;&gt;&gt; a = "hello"*10000</p>
<p>&gt;&gt;&gt; b = "hello"*10000</p>
<p>&gt;&gt;&gt; id(a)</p>
<p>2101983776176</p>
<p>&gt;&gt;&gt; id(b)</p>
<p>2101983826240</p>
<p>#元组没有复用</p>
<p>结论二：只要是"变量=对象"赋值，不论对象是否为可变还是不可变对象，其流程都是新创建一个对象，然后将变量指向这个新的对象<strong>（除去复用的情况）</strong>。</p>
<p>&gt;&gt;&gt; a = "hello world"</p>
<p>&gt;&gt;&gt; b = a #将a所引用的对象的地址也放入b中</p>
<p>&gt;&gt;&gt; a = "hello python" #创建一个"hello
python"对象，将其地址放入a中，不影响b</p>
<p>&gt;&gt;&gt; a is b</p>
<p>False</p>
<p>&gt;&gt;&gt; a = "hello world" + "python"
#字符串连接不会直接更改原字符串，而是新创建一个字符串保存连接后的结果</p>
<p>&gt;&gt;&gt; a is b</p>
<p>False</p>
<p><img src="https://s2.loli.net/2025/01/28/A5cHyYUQOxnzk9s.png"
style="width:5.76806in;height:1.8125in" /></p>
<p>#列表虽然是可变对象，但由于"="依次也是同理。</p>
<p>&gt;&gt;&gt; a = [1,2,3]</p>
<p>&gt;&gt;&gt; b = a</p>
<p>&gt;&gt;&gt; a = [4,5,6]</p>
<p>&gt;&gt;&gt; a is b</p>
<p>False</p>
<p>结论三：非"="赋值，而是对对象进行修改/创建，需要考虑可变变量和不可变变量。</p>
<p>&gt;&gt;&gt; a = "hello world"</p>
<p>&gt;&gt;&gt; b = a</p>
<p>&gt;&gt;&gt;
a.replace("world","python")#字符串是不可变变量，因此replace函数所做的是重新创建一个对象，为'hello
python'。但并没有将新对象的地址赋给变量a，变量a中仍然保持了"hello
world"对象的地址。因此a is b结果为True</p>
<p>'hello python'</p>
<p>&gt;&gt;&gt; a is b</p>
<p>True</p>
<p><img src="https://s2.loli.net/2025/01/28/W2pTMNwOPH5XoBS.png"
style="width:5.76806in;height:2.47361in" /></p>
<p>&gt;&gt;&gt; a = [1,2,3]</p>
<p>&gt;&gt;&gt; b = a</p>
<p>&gt;&gt;&gt; a.append(4)
#列表是可变变量，因此append()所做的是将变量a所引用的对象进行修改，又由于b引用的也是这个对象，所以b也被修改了，从而a
is b结果为True</p>
<p>&gt;&gt;&gt; a</p>
<p>[1, 2, 3, 4]</p>
<p>&gt;&gt;&gt; b</p>
<p>[1, 2, 3, 4]</p>
<p>&gt;&gt;&gt; a is b</p>
<p>True</p>
<p>&gt;&gt;&gt; a = [1,2,3]</p>
<p>&gt;&gt;&gt; b = a</p>
<p>&gt;&gt;&gt; a[0] = 0
#这是列表的修改操作，注意和上面列表的重新赋值操作进行区分</p>
<p>&gt;&gt;&gt; a</p>
<p>[0, 2, 3]</p>
<p>&gt;&gt;&gt; b</p>
<p>[0, 2, 3]</p>
<p>&gt;&gt;&gt; a is b</p>
<p>True</p>
<h3 id="python中的函数传递">&gt;&gt;&gt;Python中的函数传递</h3>
<p>python中的函数传递相当于"形参 = 实参"，传递的是引用的地址。</p>
<p>def fn(var):<br />
print(var,id(var)) #1 140717808961976<br />
var = 3 #相当于重新创建一个对象3，赋给var，不会影响a<br />
print(var, id(var)) #3 140717808962040</p>
<p>a = 1<br />
print(a,id(a)) #1 140717808961976<br />
fn(a)<br />
print(a,id(a)) #1 140717808961976</p>
<p>def fn(var):<br />
print(var,id(var))<br />
var.append(4)
#由于是可变变量，且不是"="操作而是修改操作，因此会影响a<br />
print(var, id(var))<br />
<br />
a = [1,2,3]<br />
print(a,id(a))<br />
fn(a)<br />
print(a,id(a))</p>
<p>[1, 2, 3] 2854761517440</p>
<p>[1, 2, 3] 2854761517440</p>
<p>[1, 2, 3, 4] 2854761517440</p>
<p>[1, 2, 3, 4] 2854761517440</p>
<p>def fn(var):<br />
print(var,id(var))<br />
var[2]=0
#由于是可变变量，且不是"="赋值操作而是修改操作，因此会影响a<br />
<br />
print(var, id(var))<br />
<br />
a = [1,2,3]<br />
print(a,id(a))<br />
fn(a)<br />
print(a,id(a))</p>
<p>[1, 2, 3] 1650276684160</p>
<p>[1, 2, 3] 1650276684160</p>
<p>[1, 2, 0] 1650276684160</p>
<p>[1, 2, 0] 1650276684160</p>
<p>def fn(var):<br />
print("var",var,id(var))<br />
var2 = []
#新开辟一个存储空间创建一个对象[],另开辟一个空间创建一个变量var2，将对象[]的内存地址放入var2中<br />
print("var2",var2, id(var2))<br />
for i in var: #依次取出var中所有元素的变量地址<br />
var2.append(i) #将地址依次放入var2所引用的列表对象的中<br />
print("var",var, id(var))<br />
print("var2",var2, id(var2))<br />
<br />
print("var[0]", id(var[0]))<br />
print("var2[0]",id(var2[0]))<br />
var2[0] = 0
#var2的第一个元素是数值，不可修改，因此新开辟一个存储空间创建一个对象0，将其地址放入var2所引用的列表对象的中</p>
<p>var [0] = 6
#新开辟一个存储空间创建一个对象0，将其地址放入var所引用的列表对象的中（注意var与a引用同一个列表对象，而var2引用另外一个）<br />
print("var[0]", id(var[0]))<br />
print("var2[0]",id(var2[0]))<br />
<br />
print("var",var, id(var))<br />
print("var2",var2, id(var2))<br />
<br />
a = [1,2,3]<br />
print("a",a,id(a))<br />
fn(a)<br />
print("a",a,id(a))</p>
<p>a [1, 2, 3] 1705682194816</p>
<p>var [1, 2, 3] 1705682194816</p>
<p>var2 [] 1705684722112</p>
<p>var [1, 2, 3] 1705682194816</p>
<p>var2 [1, 2, 3] 1705684722112</p>
<p>var[0] 140717808961976</p>
<p>var2[0] 140717808961976</p>
<p>var[0] 140717808962136</p>
<p>var2[0] 140717808961944</p>
<p>var [6, 2, 3] 1705682194816</p>
<p>var2 [0, 2, 3] 1705684722112</p>
<p>a [6, 2, 3] 1705682194816</p>
<p>下面我将a变成一个二维列表，此时var2对第二层列表的修改会影响var和a。</p>
<p>def fn(var):<br />
print("var",var,id(var))<br />
var2 = []<br />
print("var2",var2, id(var2))<br />
for i in var:<br />
var2.append(i)
#相当于一个浅拷贝，只将列表第一层又拷贝了一份，但第二层是引用地址。<br />
print("var",var, id(var))<br />
print("var2",var2, id(var2))<br />
<br />
print("var[0]", id(var[0]))<br />
print("var2[0]",id(var2[0]))<br />
var2[3][0] = 0
#因为var的第四个元素是列表，可修改，因此会对var和a产生影响<br />
var[0] = 6 #不会对var2产生影响<br />
print("var[0]", id(var[0]))<br />
print("var2[0]",id(var2[0]))<br />
<br />
print("var",var, id(var))<br />
print("var2",var2, id(var2))<br />
<br />
a = [1,2,3,[1,2,3]]<br />
print("a",a,id(a))<br />
fn(a)<br />
print("a",a,id(a))</p>
<p>a [1, 2, 3, [1, 2, 3]] 2371096664256</p>
<p>var [1, 2, 3, [1, 2, 3]] 2371096664256</p>
<p>var2 [] 2371098785984</p>
<p>var [1, 2, 3, [1, 2, 3]] 2371096664256</p>
<p>var2 [1, 2, 3, [1, 2, 3]] 2371098785984</p>
<p>var[0] 140717808961976</p>
<p>var2[0] 140717808961976</p>
<p>var[0] 140717808962136</p>
<p>var2[0] 140717808961976</p>
<p>var [6, 2, 3, [0, 2, 3]] 2371096664256</p>
<p>var2 [1, 2, 3, [0, 2, 3]] 2371098785984</p>
<p>a [6, 2, 3, [0, 2, 3]] 2371096664256</p>
<p><img src="https://s2.loli.net/2025/01/28/gWwdUqhsIxP6Qu7.png"
style="width:2.75591in;height:2.4875in" /><img
src="https://s2.loli.net/2025/01/28/RGTuY8LwfMhJCvK.png"
style="width:2.75591in;height:2.25775in" /></p>
<h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3>
<p>深拷贝和浅拷贝不考虑对象可复用机制，例如超过[-5,256]的数值也同样能够复用。</p>
<p>import copy</p>
<p>a = [1,2,3,[1,2,3]]</p>
<p>b = a.copy()#浅拷贝，只拷贝第一层</p>
<p>c = copy.deepcopy(a) #深拷贝，完全拷贝一份</p>
<p>a[0] = 0</p>
<p>print(a,b,c)</p>
<p>a[3][0] = 0</p>
<p>print(a,b,c)</p>
<p>a[3] = 0</p>
<p>print(a,b,c)</p>
<p>[0, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]]</p>
<p>[0, 2, 3, [0, 2, 3]] [1, 2, 3, [0, 2, 3]] [1, 2, 3, [1, 2, 3]]</p>
<p>[0, 2, 3, 0] [1, 2, 3, [0, 2, 3]] [1, 2, 3, [1, 2, 3]]</p>
<p><img src="https://s2.loli.net/2025/01/28/1VOSK8hxuaq2kgX.png"
style="width:5.51181in;height:3.31555in" /></p>
<h3 id="python的对象复用机制">Python的对象复用机制</h3>
<p>在Python中，对于部分不可变对象存在着复用机制。具体来说，处于[-5,
256]之间的整型 (int)
数据对象以及部分字符串对象有着复用机制，同样是不可变对象的元组则没有复用机制。之所以说只有部分字符串有复用机制是，因为有一些特例，比如当字符串足够长的时候，Python在赋值时不会复用字符串；还有字符串有空格的话，Python也不会复用这一字符串。</p>
<p>&gt;&gt;&gt; a = [288]</p>
<p>&gt;&gt;&gt; c = [288]</p>
<p>&gt;&gt;&gt; a is c
#同样是288，但是并没有复用，而是开辟了两个存储空间</p>
<p>False</p>
<p>&gt;&gt;&gt; id(a[0])</p>
<p>2101978505456</p>
<p>&gt;&gt;&gt; id(c[0])</p>
<p>2101978511088</p>
<p>&gt;&gt;&gt; a[0] is c[0]</p>
<p>False</p>
<blockquote>
<p>注意，Pycharm编译器中的整数复用范围不一样了，详见：<br />
<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/678796946">Python中小整数池和Pycharm中的大整数池
- 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="时间复杂度">时间复杂度</h1>
<p>折半查找算法的时间复杂度</p>
<p><span
class="math display">\[第1轮查找后，还剩下\frac{1}{2}n\]</span></p>
<p><span class="math display">\[第2轮查找后，还剩下\frac{1}{2^{2}
}n\]</span></p>
<p><span class="math display">\[第3轮查找后，还剩下\frac{1}{2^{3}
}n\]</span></p>
<p><span class="math display">\[\ldots\]</span></p>
<p><span class="math display">\[第y轮查找后，还剩下\frac{1}{2^{y}
}n\]</span></p>
<p>最终的边界条件为：只剩下一个数，即</p>
<p><span class="math display">\[\frac{1}{2^{y} }n = 1\]</span></p>
<p>那么就有：</p>
<p><span class="math display">\[y = \log_{2}n\]</span></p>
<h1 id="未整理">未整理</h1>
<p>1.pycharm中f类快捷键无法使用，可能时f类按键被锁定，"Fn+Esc"解除f类按键锁定</p>
<p>2.下载的python
3.11.5是解释器软件，将python代码翻译成计算机能够识别的0，1，下载的pycharm是python语言的集成开发环境平台（Integrated
Development Environment，IDE）</p>
<p>3.cmd 命令行解释器 通过键入"python"调用python解释器程序</p>
<p>4. <img src="https://s2.loli.net/2025/01/28/vVfNeh9M7SWiJrI.png"
style="width:5.76806in;height:2.82361in" /></p>
<p>5.单行注释：#与后面的内容建议以一个空格隔开</p>
<p>6.多行注释：""" 注释内容 """</p>
<p>7.Ctrl+D 复制代码行</p>
<p>8.使用函数type()返回括号中字面量或变量的数据类型，但不会显示在屏幕上，需要使用print()函数显示出来</p>
<p>9.数据类型之间相互转换</p>
<p>9.1 int(x) 将x转换成整数</p>
<p>9.2 float(x) 将x转换成浮点数</p>
<p>9.3 str(x) 将x转换成字符串</p>
<p>以上三个函数与type()一样有返回值，可以直接使用print()函数输出结果，也可以将其赋值为变量</p>
<p>10.将浮点数转换成整数，小数部分直接去除</p>
<p>11.标识符是用户在编程时所使用的一系列名字，用于给变量、类、方法进行命名</p>
<p>标识符的命名注意点：</p>
<p>11.1
内容限定：只允许出现英文、中文、数字、下划线，不推荐使用中文，<mark>数字不可以开头！</mark></p>
<p>11.2 大小写敏感</p>
<p>11.3 不可使用关键字</p>
<p>变量命名规范（建议）：见名知意、下划线命名、英文字母全小写</p>
<p>12.算术（数学）运算符</p>
<p><img src="https://s2.loli.net/2025/01/28/yst8hulN3JiADRC.png"
style="width:5.76806in;height:2.75417in" /></p>
<p>Int / int 的运算结果数据类型为浮点型 float</p>
<p>13. 复合赋值运算符</p>
<p><img src="https://s2.loli.net/2025/01/28/5mlgYB63LJITtUZ.png"
style="width:5.76806in;height:1.81042in" /></p>
<p>14. 字符串的定义方式</p>
<p>14.1 使用单引号 name ='字符串'</p>
<p>14.2 使用双引号 name ="字符串"</p>
<p>14.3 使用三引号 name =""" 字符串
字符串"""（没有赋值等号就是多行注释，有的话就是字符串定义）</p>
<p>15. 如何需要定义的字符串中包含单引号、双引号</p>
<p>15.1 如果包含单引号，则用双引号去定义字符串</p>
<p>15.2 如果包含双引号，则用单引号去定义字符串</p>
<p>15.3 或者使用转移字符（\）来讲引号解除效用，变成普通字符 例子name =
"<mark>/"</mark>字符串"</p>
<p>16.
字符串的拼接。可以使用"+"来实现字面量之间、变量之间、字面量和变量之间的拼接。但是字符串变量和整数/浮点数等其他类型变量不能直接使用"+"进行拼接。</p>
<p>17.使用占位的形式完成拼接</p>
<p>str1 = "字符串1"</p>
<p>str2 = "字符串2 %s" % str1</p>
<p>str3 = "字符串3和%s和%s" %（str1，str2）</p>
<p>其中，%表示接下来要占位，s表示将变量变成字符串放入占位的地方</p>
<p>18. Python中支持非常多的数据类型占位</p>
<p>%s 表示将内容转化为字符串，放入占位位置</p>
<p>%d 表示将内容转换成整数，放入占位位置</p>
<p>%f 表示将内容转换成浮点型，放入占位位置</p>
<p>19. 使用占位格式化的精度控制</p>
<p>使用辅助符号"m.n"来控制数据的精度</p>
<p>m，控制宽度，要求是数字（很少使用），设置的宽度小于数字自身，不生效</p>
<p>n，控制小数点精度，要求是数字，会进行小数的四舍五入</p>
<p>如%5d
表示将整数的宽度控制在5为，如数字11被设置成5d，就会变成[空格][空格][空格]11</p>
<p>如%5.2f 表示将宽度控制为5，将小数点的精度设置为2</p>
<p>需要注意，小数点和小数部分也算入宽度计算，如对11.345设置了%7.2f，最终的结果为[空格]
[空格]11.35</p>
<p>又如%.2f表示不限制宽度，只设置小数点精度为2</p>
<p>20. 字符串的格式化2 （快速写法）</p>
<p>通过语法
f"字符串内容{变量}"的方式快速，此方式不考虑数据类型和数据精度</p>
<p>（f是format的首字母）</p>
<p>21. 对表达式进行格式化</p>
<p>表达式：一条具有明确执行结果的代码语句</p>
<p>在无需使用变量进行数据存储的时候，可以直接格式化表达式来简化代码</p>
<p>如 print("1 *1 的结果是： %d" % (1*1))</p>
<p>又如 print(f"1*1 的结果是： {1*1}")</p>
<p>22. input()函数会将所有的输入内容转化为字符串类型</p>
<p>23. 比较运算符</p>
<p><img src="https://s2.loli.net/2025/01/28/V8lELo59KB1Wz6S.png"
style="width:5.76806in;height:2.17986in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/tH2yCZAbYdgPRjc.png"
style="width:1.9562in;height:1.57744in" />24.
默认print语句输出内容会自动换行，如果输出不换行的gongne能够，在print语句后面加上"end="</p>
<p>print("Hello") print("Hello"，end=' ')</p>
<p>print("World") print("World"，end=' ')</p>
<p>25.制表符 \t ，相当于tab键，可以让多行字符串实现对齐</p>
<p>26.while循环和for循环的区别，for循环也称作遍历循环</p>
<p><img src="https://s2.loli.net/2025/01/28/YtDKhV97L8nf13I.png"
style="width:5.76806in;height:2.21597in" /></p>
<p>27. for 变量 in 数据集（序列类型，包括字符串、列表、元组等）</p>
<p>理论上讲for循环无法构建无限循环（被处理的数据集不可能无限大）</p>
<p>28.range()函数</p>
<p>语法一：range(num)
获取一个从0开始，到num结束的数字序列（不含num本身），如range(5)的结果是0
1 2 3</p>
<p>语法二：range(num1,num2)，获得一个从num1开始，到num2结束的数字序列（不含num2本身）</p>
<p>语法三：range(num1,num2,step)，获得一个从num1开始，到num2结束的数字序列（不含num2本身），数字之间的步长是step</p>
<p>29.for循环中的临时变量，在for循环外也能访问到，规范上是不允许的，但实际上是可以的</p>
<p><img src="https://s2.loli.net/2025/01/28/NsYchMilQ1p9GRj.png"
style="width:1.77947in;height:1.62017in" /></p>
<p>30.continue关键字用于：中断本次循环，直接进入下一次循环，可用于for循环和while循环，效果是一致的</p>
<p>31.break关键字用于直接结束循环，可用于for循环和while循环，效果是一致的</p>
<p>32.函数是组织好的，可重复使用的，用来实现特定功能的代码段</p>
<p>33.为什么要使用函数？为了得到一个正对需求、可供重复使用的代码段，提高了程序的复用性，减少重复性代码，提高开发效率</p>
<p>34. 函数的定义</p>
<p>def 函数名（传入参数）：</p>
<p>函数体</p>
<p>return 返回值</p>
<p>35.函数体遇到return关键字之后，后面的代码都不会执行了</p>
<p>36.如果一个函数体没有return，那么函数的返回值是None这个特殊的字面量，其类型是class'NoneType</p>
<p>37.在if语句中，None相当于False</p>
<p>38.None可用于声明无初始内容的变量</p>
<p>39.函数的说明文档：</p>
<p><img src="https://s2.loli.net/2025/01/28/K7UQwbv2ImtVnRr.png"
style="width:5.76806in;height:3.14028in" /></p>
<p>40.变量的作用域：局部变量和全局变量</p>
<p>41.global关键字能让在函数内定义的局部变量变成全局变量，如果没有global，及时局部变量和全局变量的名称相同，两者也是不会相互影响，如下图例子</p>
<p><img src="https://s2.loli.net/2025/01/28/I7MzY8c53LmZgDS.png"
style="width:2.31956in;height:2.77098in" /><img
src="https://s2.loli.net/2025/01/28/fIlXYobzqJsWQFS.png"
style="width:1.76311in;height:2.67239in" /></p>
<p>42.数据容器</p>
<p>一个数据容器可以容纳多份数据</p>
<p>一种可以容纳多份数据的<strong><mark>数据类型</mark></strong>，容纳的每一份数据称之为一个元素。每一个元素，可以是任意类型的数据，如字符串、数字、布尔等。</p>
<p>43.数据容器根据特点不同，如：是否支持重复元素、是否可以修改、是否有序等分为5类，分别是：列表list、元组tuple、字符串str、集合set、字典dict</p>
<p>44.列表的定义</p>
<p><img src="https://s2.loli.net/2025/01/28/MWilk15VeQOyHmB.png"
style="width:5.50723in;height:2.15289in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/pct5C1bHOX8ajUV.png"
style="width:3.28489in;height:2.90293in" /></p>
<p>45.列表可以一次存储多个数据，且数据类型可以不同，支持列表嵌套</p>
<p>46.下标索引</p>
<p>①正向</p>
<p><img src="https://s2.loli.net/2025/01/28/BFnG6pTzHcbfVtk.png"
style="width:5.76806in;height:2.7625in" /></p>
<p>②反向</p>
<p><img src="https://s2.loli.net/2025/01/28/quKJsC4SFcoPRNL.png"
style="width:5.76806in;height:2.19514in" /></p>
<p>③嵌套列表</p>
<p><strong>列表[index][index]</strong></p>
<p><img src="https://s2.loli.net/2025/01/28/iepsYTXxSD6z51w.png"
style="width:5.63918in;height:1.91677in" /></p>
<p>47.函数是一个封装的代码单元，可以提供特定功能，如果将函数定义为class（类）的成员，那么函数会被称之为：方法</p>
<p>48.方法和函数的功能一样，有传入参数，有返回值，知识方法的使用格式不同：</p>
<p>函数可以通过函数名传入参数直接调用，方法的调用需要先获得方法的类对象，然后通过"类对象.方法"的方式进行调用</p>
<p>49.列表的常用操作方法</p>
<p><img src="https://s2.loli.net/2025/01/28/8xK2j1qSFVZbtpN.png"
style="width:5.76806in;height:2.13542in" /></p>
<p>①查询：查找指定元素在列表的下标，如果找不到，报错ValueError</p>
<p>语法：列表.index（元素）</p>
<p>②修改：修改特定位置（索引）的元素值</p>
<p>语法：列表[下标]=值</p>
<p>③插入：插入元素</p>
<p>语法：列表.insert（下标，元素），在指定的下标位置，插入指定的元素，原下标位置的元素后移</p>
<p>④追加：追加单个元素</p>
<p>语法：列表.append（元素），将指定元素，追加到列表的尾部</p>
<p>⑤追加：追加一批元素</p>
<p>语法：列表.extend（其他数据容器），将其他数据容器的内容取出，依次追加到列表尾部</p>
<p>⑥删除（通过指定下标）</p>
<p>语法1：del 列表[下标]</p>
<p>语法2：列表.pop(下标)，pop方法的实际意义是取出列表中的指定元素并返回，可以没有变量接收这个返回值，原列表中的数据仍然被移除。</p>
<p>⑦删除（通过指定元素）</p>
<p>语法：列表.remove（元素），从前到后进行搜索，删除找到的第一个，并不是全部删除</p>
<p>⑧清空列表：但列表仍然存在</p>
<p>语法：列表.clear（）</p>
<p>⑨统计某元素在列表内的数量</p>
<p>语法：列表.count（元素）</p>
<p>⑩统计列表内，有多少元素</p>
<p>语法：len（列表）</p>
<p>50.列表的遍历</p>
<p>①使用while循环，控制条件index &lt; len(列表)，index从0开始</p>
<p>②使用for循环，for 临时变量 in 数据容器：</p>
<p>51.元组tuple</p>
<p>列表是可以修改的，但如果想要传递的信息<strong>不能被篡改</strong>，列表就不合适了。</p>
<p>元组使用小括号定义，列表使用中括号定义。元组也能包含任意数据类型。</p>
<p>空元组定义 my_tuple = ()或者my_tuple = tuple()</p>
<p>只包含一个元素的元组定义 my_tuple =
("元素"<strong><mark>，</mark></strong>)，尤其注意要加上一个逗号！</p>
<p>元组也是可以嵌套。</p>
<p>52.元组的操作</p>
<p>使用中括号中加下标索引进行定位，与列表一样</p>
<p>①查找index（）②统计某个元素出现的个数count（）③统计元组内元素个数len（）</p>
<p>53.元组内的元素不能够修改，但是如果在元组内<strong><mark>嵌套了一个list</mark></strong>，list内的内容是可以修改的</p>
<p>54.从数据容器的视角看字符串</p>
<p><img src="https://s2.loli.net/2025/01/28/C4QAZgoxWBs165j.png"
style="width:5.76806in;height:2.49028in" /></p>
<p>字符串也是和元组一样，是一个<strong><mark>不可修改</mark></strong>的数据容器</p>
<p>①查询元素的下标索引值index（），如果是查询连起来的多个字符，则输出第一个字符的位置</p>
<p>②字符串的替换
replace（字符串1，字符串2），将字符串内的全部字符串1替换为字符串2，<strong><mark>这不是修改字符串本身，而是得到了一个新字符串，会得到一个返回值</mark></strong></p>
<p>③字符串的分割
split（）按照指定的分隔符字符串，将字符串划分为多个字符串，并存入<strong><mark>列表对象</mark></strong>中，注意本身字符串是不变的，而是得到了一个<strong><mark>列表对象</mark></strong>。</p>
<p>④字符串的规整操作</p>
<p>strip（）
去除前后空格和回车换号符，如果传入元素strip（"字符串"）去除前后指定字符，<strong><mark>不关心需删除字符串的顺序，以单个字符进行匹配</mark></strong>。如下图</p>
<p><img src="https://s2.loli.net/2025/01/28/6cwCbKDkjNrU7GQ.png"
style="width:5.51417in;height:1.29868in" /></p>
<p>55.序列</p>
<p>序列是指内容连续、有序、可使用下标索引的一类数据容器，包括列表、元组、字符串</p>
<p>56.序列的切片操作</p>
<p>切片：从一个序列，取出一个子序列</p>
<p><img src="https://s2.loli.net/2025/01/28/xHqmPKspYtjiy8B.png"
style="width:5.66696in;height:2.22928in" /></p>
<p>注意：切片操作不会影响序列本身，而是会得到一个新的序列（元组、字符串都不支持修改）</p>
<p>57.集合set</p>
<p>列表、元组、字符串都支持重复元素且有序</p>
<p>集合不支持重复元素且无序，生成之后自带去重处理且每次顺序都是不一样的</p>
<p><img src="https://s2.loli.net/2025/01/28/VAvwKCja4RFHrtL.png"
style="width:3.28489in;height:1.65981in" /></p>
<p>58.集合的常用操作</p>
<p><img src="https://s2.loli.net/2025/01/28/DK9igL3MZUhCc5W.png"
style="width:5.76806in;height:2.56806in" /></p>
<p>①添加 集合.add( )</p>
<p>②移除 集合.remove( )</p>
<p>③从集合中取出第一个元素 集合.pop( )</p>
<p>④清空集合 集合.clear( )</p>
<p>⑤取出2个集合的差集
集合1.difference（集合2），取出集合1有而集合2没有的，<strong><mark>得到一个新集合</mark></strong>，集合1和集合2不变</p>
<p>⑥消除差集 集合1.difference.update（集合2）
对比集合1和集合2，在集合1内，删除和集合2相同的元素。最后集合1会被修改，集合2不变</p>
<p>⑦集合合并
集合1.union（集合2），将集合1和集合2组成新集合，<strong><mark>得到新集合</mark></strong>，集合1和集合2不变</p>
<p>⑧统计集合元素数量 集合.len（）</p>
<p>⑨集合遍历 集合不支持下标索引，所以不能用while循环，只能用for循环</p>
<p>59.数据容器 字典</p>
<p>通过字典dict可以实现通过key找到value的操作</p>
<p>字典的定义也使用{}，但存储的不是一个个元素，而是一个个键值对</p>
<p><img src="https://s2.loli.net/2025/01/28/JVqomd1ntgPOQuf.png"
style="width:5.41in;height:1.80565in" /></p>
<p>60.字典的Key是不可以重复的，如果定义重复的key，后一组key键值对会覆盖掉前一组。</p>
<p>61.字典和集合一样，不可以使用下标索引，但可以通过key值来取得对应的Value。语法：字典[Key]</p>
<p>62.字典的Key和Value可以是任意数据类型（Key不可为字典、列表[]、集合{}，可以是字符串、元组（），Value可以为字典）</p>
<p>63.字典的常用操作</p>
<p><img src="https://s2.loli.net/2025/01/28/RNpzbfnavZ7EHLG.png"
style="width:5.76806in;height:2.06528in" /></p>
<p>①新增/更新元素</p>
<p>语法 字典[Key]=Value</p>
<p>②删除元素</p>
<p>语法：字典.pop（Key），结果返回指定Key的Value,同时字典被修改，指定Key的数据被删除</p>
<p>③清空字典</p>
<p>语法：字典.clear()</p>
<p>④获取全部的key</p>
<p>语法：字典.keys（），返回字典中的全部key</p>
<p>⑤遍历字典</p>
<p>1.通过字典.keys（）拿到字典的所有key，再for key in keys：</p>
<p>2.for key in my_dict: 此时key拿到的是字典所有的key</p>
<p>⑥统计字典内的元素数量</p>
<p>语法：len(字典)</p>
<p>64.五种数据容器的对比</p>
<p><img src="https://s2.loli.net/2025/01/28/MAaWx7RDzf9TkId.png"
style="width:5.76806in;height:2.36319in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/snKaCHlXF9IUJZk.png"
style="width:4.38911in;height:2.63902in" /></p>
<p>65.数据容器的通用操作</p>
<p><img src="https://s2.loli.net/2025/01/28/qAQKsCvrIL4eEW6.png"
style="width:5.76806in;height:2.64306in" /></p>
<p>①len（容器）②max（容器）③min（容器）</p>
<p>④容器的通用转换功能：list（容器）字符串转列表中每一个字符都会被单独拿出来作为一个元素，字典转列表中所有的Value都会被舍去只留下每个key作为一个元素、str（容器）字典转换成字符串中Value会保留下来、tuple（容器）字典转元组中所有的Value都会被舍去只留下每个key作为一个元素、set（容器）字典转集合中所有的Value都会被舍去只留下每个key作为一个元素</p>
<p>⑤通用排序功能
sorted（容器，reverse=True【默认是False正序升序，如果要倒序则关键词值填True】），<strong><mark>注意：排序之后的结果会变成列表对象</mark></strong>。</p>
<p>66.ASAⅡ码表</p>
<p>在程序中，字符串所用的所有字符如：大小写英文单词、数字、特殊符号都有其对应的ASACⅡ码表值。每个字符都能对应上一个数字的码值，字符串进行比较就是基于数字的码表大小进行比较</p>
<p>67.字符串是从左向右依次按位进行比较</p>
<p><img src="https://s2.loli.net/2025/01/28/V9PYcZSvhB3pTJ5.png"
style="width:5.56279in;height:5.66696in" /></p>
<p>68.函数的多返回值</p>
<p>return 关键词后跟多个变量，用逗号分开，可以是不同数据类型</p>
<p>语法 def test_return(): return 1，2</p>
<p>x，y=test_return</p>
<p>69.函数的多种传参方式</p>
<p>①位置参数：调用函数时根据函数定义的参数位置来传递参数。注意：传递的参数和定义的参数的顺序及个数必须一致</p>
<p><img src="https://s2.loli.net/2025/01/28/UVmAGQLyw4kEvqX.png"
style="width:4.44467in;height:1.22228in" /></p>
<p>②关键字参数：函数调用时，通过"键=值"的形式传递参数。可以让函数更加清晰、容易使用，同时也清楚了参数的顺序需求。注意，函数调用时，如果有位置参数，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序</p>
<p><img src="https://s2.loli.net/2025/01/28/bjaXlAQ3mvhoFye.png"
style="width:4.43773in;height:1.70148in" /></p>
<p>③缺省参数：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值。注意：所有位置参数必须出现在默认参数之前，包括函数定义和调用。如果为省缺参数传值则修改默认参数值，否则使用这个默认值。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="image36.png" style="width:4.278in;height:1.46535in" /></p>
<p>④不定长参数：不定长参数也叫做可变参数，用于不确定调用的时候会传递多少个参数（不传参）。有两种方式：位置传递和关键字传递</p>
<p><strong>位置传递：使用*，</strong>传进去的所有参数都会被args变量收集，它会根据传进参数的位置合并成一个元组（tuple），args是元组类型。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="image37.png" style="width:1.76398in;height:1.98621in" />
<img src="https://s2.loli.net/2025/01/28/vW67BPQ9RynbOlA.png"
style="width:3.38906in;height:1.55564in" /></p>
<p><strong>关键字传递：</strong>使用**，参数是"键=值"形式的情况下，所有的"键=值"都会被kwargs接受，同时会根据"键=值"组成字典。</p>
<p>70.函数作为参数传递</p>
<p>计算逻辑的传递，而非数据的传递</p>
<p>71.lambda匿名函数</p>
<p>def可以定义有名称的函数，lambda可以定义匿名函数（无名称）。有名称的函数，可以基于名称重复使用，无名称的匿名函数，只可临时使用一次。</p>
<p><img src="https://s2.loli.net/2025/01/28/HtR8Dfi9Y6V1kTC.png"
style="width:4.85442in;height:1.38202in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/jMYFRfOyZacKJEo.png"
style="width:5.76806in;height:2.57083in" /></p>
<p>72.文件编码</p>
<p>丰富的文件内容通过不同的编码翻译成二进制，让计算机进行识别</p>
<p>计算机中有许多种可用编码：UTF-8，GBK，Big5等</p>
<p>73.文件的打开</p>
<p>open（）函数可以打开一个已经存在的文件或者创建一个新文件</p>
<p><img src="https://s2.loli.net/2025/01/28/UYdhmzFu197Q2KX.png"
style="width:5.76806in;height:1.43819in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/nlNqj1S9FTaVgdm.png"
style="width:5.76806in;height:1.10556in" /></p>
<p>74.打开、读取、关闭文件对象</p>
<p>①文件对象.read（num），num表示读取数据的长度（字符），如果没有传入num，那么就表示读取文件中所有的数据。返回一个<strong><mark>字符串</mark></strong>。</p>
<p>②文件对象.readline（）一次读取一行内容，返回一个<strong><mark>字符串</mark></strong>。</p>
<p>③文件对象.readlines（）可以按照行的方式把整个文件中的内容进行一次性读取，并返回一个<strong><mark>列表</mark></strong>，其中的每一行数据作为一个元素。<strong><mark>注意，如果一个程序中调用了多个read（）/readlines（）/
readline（），第二次读取会接着第一次读取继续，而不是重新读取</mark></strong>。</p>
<p>④for循环读取文件行</p>
<p>for line in open（"python.txt"，"r"）</p>
<p>⑤文件关闭，接触文件的占用</p>
<p>文件对象.close( )</p>
<p>或者打开文件时使用</p>
<p>with open（"python.txt","r"，encoding = "UTF-8"） as 文件对象名：</p>
<p><img src="https://s2.loli.net/2025/01/28/gbEzLi8fPYwGsyl.png"
style="width:5.76806in;height:2.09236in" /></p>
<p>75.打开、覆盖读写和追加读写文件对象</p>
<p>f = open("python.txt"，"w")
#以覆盖读写模式打开文件或者选择模式"a"，就是以追加读写的方式打开文件。</p>
<p>f.write（'内容'） #写入内容</p>
<p><strong><mark>f.flush
#在文件还在运行时，虽然已经执行写入代码但仍然时在内存中，当程序结束之后，不需要flush方法也会自动写入</mark></strong></p>
<p>注意：直接调用write（）方法，内容并未被直接写入文件，而是在内存之中，当调用flush（）方法时，内容才会真正写入文件。这样做时为了避免频繁的操作硬盘，导致效率下降。</p>
<p>f.close（）内置的flush功能</p>
<p>76.python捕获异常</p>
<p>当我们的程序遇到了bug，那么接下来有两种情况：①整个程序因为一个bug停止工作（也是初学者面临的大多数情况）②对bug进行提醒，整个程序继续运行（也叫做捕获异常，在实际工作中肯定不能因为一个小bug就让整个程序崩溃）</p>
<p>捕获异常的作用在于：提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段。</p>
<p><img src="https://s2.loli.net/2025/01/28/PVeTr9J3I6nR5bo.png"
style="width:2.09038in;height:1.09728in" /><img
src="https://s2.loli.net/2025/01/28/ztOQBj5Iec8NdP9.png"
style="width:3.48149in;height:0.96353in" /></p>
<p>77.捕获指定异常</p>
<p><img src="https://s2.loli.net/2025/01/28/e9PFB451LacWHow.png"
style="width:5.31277in;height:2.15983in" /></p>
<p>78.捕获多个异常</p>
<p><img src="https://s2.loli.net/2025/01/28/eRbkUvDqhSzOjrW.png"
style="width:2.49318in;height:0.68059in" /></p>
<p>try：</p>
<p>XX</p>
<p>except <strong>Exception</strong> as e：</p>
<p>print（e） #e中包含了异常的具体信息</p>
<p><strong>#Exception是顶级异常，包括所有异常类型</strong></p>
<p>79.异常中else表示的是如果没有异常，则执行以下代码。</p>
<p><img src="https://s2.loli.net/2025/01/28/I3SuCckTBze9iPW.png"
style="width:3.146in;height:1.31257in" /></p>
<p>80.异常中finally表示的是无论是否异常都要执行的代码，例如关闭文件。</p>
<p><img src="https://s2.loli.net/2025/01/28/ZqraFzR4CpYQVUd.png"
style="width:4.22244in;height:1.63897in" /></p>
<p>81.异常的传递</p>
<p>异常具有传递性</p>
<p><img src="https://s2.loli.net/2025/01/28/TCs3JNPRXy27Bxr.png"
style="width:2.8057in;height:3.31267in" /></p>
<p>82.python的模块</p>
<p>模块是一个python文件，以.py结尾</p>
<p>模块的作用：python中有很多不同的模块，每一个模块都可以帮助我们快速的实现一些功能。</p>
<p><img src="https://s2.loli.net/2025/01/28/Zz8KRiYl6gJFQOj.png"
style="width:4.52664in;height:2.16304in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/3wa4ABztNlHXCSE.png"
style="width:2.33607in;height:2.4691in" /></p>
<p>83.自定义模块</p>
<p>同时调用两个相同名称的模块中函数，第二个函数会把第一个函数覆盖掉</p>
<p>if <mark>__name__</mark> ==
'__main__'：可以实现后面的语句在模块中运行，而在模块调用中不运行</p>
<p>84.模块文件中的__all__变量</p>
<p>相当于这个__all__变量作用在*上</p>
<p><img src="https://s2.loli.net/2025/01/28/6tbnxv8oDaUzsu3.png"
style="width:5.76806in;height:2.26042in" /></p>
<p>85.python包</p>
<p>Python的包就相当于一个文件夹，该文件夹下包含了一个__init__.py文件和多个模块文件。从逻辑上看，包的本质依然是模块。</p>
<p>当模块文件越来越多时，包可以帮助我们管理这些模块。</p>
<p><img src="https://s2.loli.net/2025/01/28/M4URD2QBYhXVcFP.png"
style="width:5.76806in;height:1.83681in" /></p>
<p>86.python包的导入</p>
<p>方式一：import 包名.模块名 调用时：包名.模块名.函数名</p>
<p>方式二：from 包名 import 模块</p>
<p>同样可以在__init__.py文件中使用__all__来控制导入*的内容</p>
<p>87.安装第三方python包</p>
<p>在cmd命令提示符中输入 pip install 包名</p>
<p>Pip默认连结国外的网站</p>
<p>pip install -I 镜像网址 包名</p>
<p><img src="https://s2.loli.net/2025/01/28/2sQy8HtTCPlnhGq.png"
style="width:5.76806in;height:1.31528in" /></p>
<p>88.json数据格式</p>
<p>Json是一种轻量级的数据交互格式，可以按照json指定的格式去组织和封装数据。</p>
<p>Json本质上是一个带有特定格式的字符串</p>
<p>主要功能：json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。</p>
<p><img src="https://s2.loli.net/2025/01/28/OaIuZMBn2hJrsw8.png"
style="width:5.76806in;height:2.88681in" /></p>
<p>89.json数据格式其实就是长得和python中字典一样的字符串，或者长的是元素是字典的列表的字符串。</p>
<p><img src="https://s2.loli.net/2025/01/28/cRUGtzij3W4wIBf.png"
style="width:5.76806in;height:1.28333in" /></p>
<p>90.python数据和json数据相互转换</p>
<p>使用模块json</p>
<p>准备符合json数据格式的python数据（字典，或者元素是字典的列表）</p>
<p>使用json.dumps(data)方法将python数据转化为json数据,如果包含中文，则需要设置ensure_ascii=False参数</p>
<p>Json_data = json.dumps(python_data，ensure_ascii=False)</p>
<p>使用json.load（data）方法将json数据转换为python数据</p>
<p>Python_data = json.load(json_data)</p>
<p>91.pyecharts包</p>
<p>全局配置选项：针对整个图像进行设置</p>
<p>系列配置选项：针对具体的轴数据进行设置</p>
<p>92.简单折线图</p>
<p><img src="https://s2.loli.net/2025/01/28/Kst367VHMnkYwgm.png"
style="width:3.20498in;height:0.87551in" /></p>
<p>93.全局配置选项：</p>
<p>使用方法set_global_opts( )，此方法中的参数需要先导入</p>
<p>From pyecharts.options import TitleOpts,LegendOpts,ToolboxOpts</p>
<p><img src="https://s2.loli.net/2025/01/28/d6gyuYl8PBhONJf.png"
style="width:6.36362in;height:3.36951in" /></p>
<p><img src="https://s2.loli.net/2025/01/28/QK8bJpA9PqhX24v.png"
style="width:5.76806in;height:1.675in" /></p>
<p>94.类、对象、属性</p>
<p><img src="https://s2.loli.net/2025/01/28/Dcf9Zmy6G32OVvs.png"
style="width:5.29194in;height:2.87515in" /></p>
<p>95.使用关键词class定义类，类包含类的属性（<strong><mark>成员变量</mark></strong>）和类的行为（<strong><mark>成员方法</mark></strong>），创建类对象的语法：对象=类名称（）</p>
<p><img src="https://s2.loli.net/2025/01/28/LwXhWlFCSbpifQJ.png"
style="width:5.68085in;height:2.24317in" /></p>
<p>96.类方法的定义语法，需要加上self，在类方法内部访问类变量需要加关键词self，但是在传入参数的时候，可以忽略self</p>
<p><img src="https://s2.loli.net/2025/01/28/EhytgoiLj9MDunK.png"
style="width:4.04882in;height:2.31956in" /><br />
<img src="https://s2.loli.net/2025/01/28/uk7leESGpLZTrwc.png"
style="width:5.76806in;height:1.26736in" /></p>
<p>97.使用__init__()方法，称之为构造方法，可以实现：</p>
<p>①在创建类对象（构造类）的时候，会自动执行②将传入参数自动传递给__init__方法使用。</p>
<p><img src="https://s2.loli.net/2025/01/28/R4VlrGduX5QsJcj.png"
style="width:2.71856in;height:2.01519in" /></p>
<p>98.魔术方法</p>
<p>__init__构造方法是Python类内置的方法之一，这些内置的类方法，各自有各自特殊的功能，这些内置办法我们称之为：魔术方法</p>
<p>99.内置方法：__str__字符串方法</p>
<p>直接print类对象，是打印其内存地址，可以通过__str__办法，控制类转换成字符串的行为</p>
<p><img src="https://s2.loli.net/2025/01/28/ba6241GvzchugLY.png"
style="width:5.15999in;height:2.01399in" /></p>
<p>100.内置方法：__lt__小于符号比较方法</p>
<p><img src="https://s2.loli.net/2025/01/28/2l4wHDCnbzimyoL.png"
style="width:4.52107in;height:2.139in" /></p>
<p>101.内置方法：__le__小于等于比较符号方法</p>
<p><img src="https://s2.loli.net/2025/01/28/KGXnI5h9rqViNQT.png"
style="width:4.93775in;height:2.53485in" /></p>
<p>102.内置方法：__eq__比较运算符实现方法</p>
<p><img src="https://s2.loli.net/2025/01/28/Sbrvn3UlBFzZLGs.png"
style="width:4.85127in;height:1.75699in" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Harlon Yan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/">http://example.com/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Harlon Yan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Causal-inference/">Causal inference</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/01/01/%E6%B5%85%E8%B0%88%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/" title="浅谈实证研究"><img class="cover" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/J6tm51LwRoGHMrF.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="info-item-2">浅谈实证研究</div></div><div class="info-2"><div class="info-item-1">本文是一份关于实证研究方法的学习笔记，主要围绕论文选题、文献回顾、实证分析流程、数据处理、回归模型构建与解读等方面展开。文章详细介绍了论文选题的步骤，强调了文献阅读的重要性，并讲解了实证论文的基准回归、稳健性检验、内生性问题处理等关键环节。同时，文章还探讨了数据获取、描述性统计分析、回归模型选择（如OLS、Logit、Probit等）、多重共线性问题以及Logit回归模型的原理和结果解读等内容。</div></div></div></a><a class="pagination-related" href="/2024/01/01/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/" title="计量经济学"><img class="cover" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/ZhbEGOaRXdkji2f.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="info-item-2">计量经济学</div></div><div class="info-2"><div class="info-item-1">本文是一份关于计量经济学的学习笔记，系统介绍了计量经济学的基本概念、方法和应用。内容涵盖计量经济学的性质、经济数据类型、简单线性回归模型、多元线性回归模型、OLS估计量的性质、假设检验、置信区间、模型设定问题（如函数形式误设、代理变量使用、测量误差等）以及异方差性问题的处理方法。</div></div></div></a><a class="pagination-related" href="/2024/01/01/%E5%8F%8C%E9%87%8D%E5%B7%AE%E5%88%86%E6%B3%95%EF%BC%88DID%EF%BC%89/" title="双重差分法（DID）"><img class="cover" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/sGNucUh9avFHTzI.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="info-item-2">双重差分法（DID）</div></div><div class="info-2"><div class="info-item-1">本文详细介绍了双重差分法（DID）及其在因果推断中的应用。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/Cf5h3dytAMaYg21.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Harlon Yan</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com//HarlonYan" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="/QQ" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #24292e;"></i></a><a class="social-icon" href="/Wechat" target="_blank" title="Wechat"><i class="fa-brands fa-weixin" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#python%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Python中的变量与对象之间的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">C语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python"><span class="toc-number">1.2.</span> <span class="toc-text">Python</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.1.</span> <span class="toc-text">可变对象和不可变对象的赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.2.</span> <span class="toc-text">&gt;&gt;&gt;Python中的函数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.3.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">Python的对象复用机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AA%E6%95%B4%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">未整理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/PPT%E4%BD%9C%E5%93%81/" title="PPT作品"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/kto9Pqvf4LECx6R.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PPT作品"/></a><div class="content"><a class="title" href="/2024/01/01/PPT%E4%BD%9C%E5%93%81/" title="PPT作品">PPT作品</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/" title="python语法笔记"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python语法笔记"/></a><div class="content"><a class="title" href="/2024/01/01/python%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/" title="python语法笔记">python语法笔记</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/%E6%B5%85%E8%B0%88%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/" title="浅谈实证研究"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/J6tm51LwRoGHMrF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅谈实证研究"/></a><div class="content"><a class="title" href="/2024/01/01/%E6%B5%85%E8%B0%88%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/" title="浅谈实证研究">浅谈实证研究</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/" title="计量经济学"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/ZhbEGOaRXdkji2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计量经济学"/></a><div class="content"><a class="title" href="/2024/01/01/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/" title="计量经济学">计量经济学</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/%E5%8F%8C%E9%87%8D%E5%B7%AE%E5%88%86%E6%B3%95%EF%BC%88DID%EF%BC%89/" title="双重差分法（DID）"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2025/01/29/sGNucUh9avFHTzI.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="双重差分法（DID）"/></a><div class="content"><a class="title" href="/2024/01/01/%E5%8F%8C%E9%87%8D%E5%B7%AE%E5%88%86%E6%B3%95%EF%BC%88DID%EF%BC%89/" title="双重差分法（DID）">双重差分法（DID）</a><time datetime="2023-12-31T16:00:00.000Z" title="发表于 2024-01-01 00:00:00">2024-01-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.loli.net/2025/01/29/w1et5oxSBqJMCim.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Harlon Yan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 3,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>